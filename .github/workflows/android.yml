name: Android CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for proper versioning
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: gradle
    
    # Improved caching strategy
    - name: Cache Gradle Dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.android/build-cache
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    # Auto-versioning setup
    - name: Set up Version Code
      id: version-code
      run: |
        # Use GitHub Run ID for version code to ensure it's always increasing
        VERSION_CODE=${{ github.run_number }}
        # Add short SHA as a version name suffix
        SHORT_SHA=$(git rev-parse --short HEAD)
        VERSION_NAME="1.0.0-$SHORT_SHA"
        echo "Generated Version Code: $VERSION_CODE"
        echo "Generated Version Name: $VERSION_NAME"
        echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
        echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
        echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
        echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
        
    - name: Setup Gradle
      run: |
        # Make gradlew executable
        if [ -f "./gradlew" ]; then
          chmod +x ./gradlew
        else
          echo "No gradlew file found in root directory"
          find . -name "gradlew" -type f -exec chmod +x {} \;
        fi
        
    - name: Build Debug APK
      run: |
        # Apply version code and name if gradlew exists in root
        if [ -f "./gradlew" ]; then
          ./gradlew assembleDebug \
          --no-daemon \
          --stacktrace \
          -PversionCode=${{ env.VERSION_CODE }} \
          -PversionName=${{ env.VERSION_NAME }}
        else
          # Try to find gradlew in subdirectories
          GRADLEW_PATH=$(find . -name "gradlew" -type f | head -n 1)
          if [ -n "$GRADLEW_PATH" ]; then
            echo "Using gradlew at: $GRADLEW_PATH"
            $GRADLEW_PATH assembleDebug \
            --no-daemon \
            --stacktrace \
            -PversionCode=${{ env.VERSION_CODE }} \
            -PversionName=${{ env.VERSION_NAME }}
          else
            echo "Failed to find gradlew file"
            exit 1
          fi
        fi
    
    - name: Find and package APK
      id: find-apk
      run: |
        # Create artifacts directory
        mkdir -p artifacts
        
        # Find all generated APK files
        APK_FILES=$(find . -name "*.apk" -type f)
        if [ -z "$APK_FILES" ]; then
          echo "No APK files found!"
          exit 1
        fi
        
        # Use the most recently modified APK
        LATEST_APK=$(ls -t $APK_FILES | head -n 1)
        echo "Found APK: $LATEST_APK"
        
        # Copy APK to artifacts directory with a standardized name
        APK_FILENAME="MoneyPulse-debug-${{ env.VERSION_NAME }}.apk"
        cp "$LATEST_APK" "artifacts/$APK_FILENAME"
        echo "APK ready at: artifacts/$APK_FILENAME"
        
        # Set environment variable for APK path
        echo "APK_PATH=artifacts/$APK_FILENAME" >> $GITHUB_ENV
        echo "apk_path=artifacts/$APK_FILENAME" >> $GITHUB_OUTPUT
        
    # Simplified artifact storage - write to actions artifact storage directly
    - name: Upload Artifacts
      run: |
        echo "::group::Uploading artifacts"
        
        # Create a tarball of the artifacts directory
        tar -czvf artifacts.tar.gz artifacts/
        
        # Artifacts are automatically saved if they're in the .github/artifacts directory
        mkdir -p .github/artifacts
        mv artifacts.tar.gz .github/artifacts/
        
        echo "Artifacts have been packaged and saved to GitHub storage"
        echo "::endgroup::"
        
    # Create GitHub Release for tagged commits (using artifact directly)
    - name: Release
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        echo "::group::Creating release"
        
        # Get the tag name
        TAG_NAME=${GITHUB_REF#refs/tags/}
        echo "Creating release for tag: $TAG_NAME"
        
        # Use GitHub CLI to create a release and upload the APK
        # This requires the GITHUB_TOKEN to have the appropriate permissions
        gh release create "$TAG_NAME" \
          --title "MoneyPulse $TAG_NAME" \
          --notes "Release $TAG_NAME" \
          "${{ env.APK_PATH }}"
        
        echo "Release created successfully"
        echo "::endgroup::"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 