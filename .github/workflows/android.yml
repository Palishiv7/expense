name: Android CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for proper versioning
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: gradle
    
    # Improved caching strategy
    - name: Cache Gradle Dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.android/build-cache
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
    
    # Auto-versioning setup
    - name: Set up Version Code
      id: version-code
      run: |
        # Use GitHub Run ID for version code to ensure it's always increasing
        VERSION_CODE=${{ github.run_number }}
        # Add short SHA as a version name suffix
        SHORT_SHA=$(git rev-parse --short HEAD)
        VERSION_NAME="1.0.0-$SHORT_SHA"
        echo "Generated Version Code: $VERSION_CODE"
        echo "Generated Version Name: $VERSION_NAME"
        echo "VERSION_CODE=$VERSION_CODE" >> $GITHUB_ENV
        echo "VERSION_NAME=$VERSION_NAME" >> $GITHUB_ENV
        echo "version_code=$VERSION_CODE" >> $GITHUB_OUTPUT
        echo "version_name=$VERSION_NAME" >> $GITHUB_OUTPUT
        
    - name: Setup Gradle
      run: |
        echo "Current working directory: $(pwd)"
        echo "Listing files in current directory:"
        ls -la
        
        # Try to find gradlew anywhere in the repository
        GRADLEW_PATH=$(find . -name "gradlew" -type f | head -n 1)
        
        if [ -n "$GRADLEW_PATH" ]; then
          echo "Found gradlew at: $GRADLEW_PATH"
          chmod +x "$GRADLEW_PATH"
          echo "GRADLEW_PATH=$GRADLEW_PATH" >> $GITHUB_ENV
          PROJECT_DIR=$(dirname "$GRADLEW_PATH")
          echo "PROJECT_DIR=$PROJECT_DIR" >> $GITHUB_ENV
          
          # Check if there's a gradle.properties file with a Windows-specific Java home
          if [ -f "$PROJECT_DIR/gradle.properties" ]; then
            echo "Found gradle.properties, checking for Windows paths"
            if grep -q "org.gradle.java.home" "$PROJECT_DIR/gradle.properties"; then
              echo "Found Java home setting in gradle.properties, creating a CI-specific version"
              # Create a backup of the original file
              cp "$PROJECT_DIR/gradle.properties" "$PROJECT_DIR/gradle.properties.original"
              # Create a new version without the Java home setting
              grep -v "org.gradle.java.home" "$PROJECT_DIR/gradle.properties.original" > "$PROJECT_DIR/gradle.properties"
              # Add a Linux-specific Java home if needed
              echo "# CI-specific settings" >> "$PROJECT_DIR/gradle.properties"
              echo "org.gradle.java.home=$JAVA_HOME" >> "$PROJECT_DIR/gradle.properties"
              echo "Modified gradle.properties for CI:"
              cat "$PROJECT_DIR/gradle.properties"
            fi
          fi
        else
          echo "No gradlew file found in repository, attempting to generate one"
          # Download and extract Gradle
          wget -q https://services.gradle.org/distributions/gradle-8.2-bin.zip
          unzip -q gradle-8.2-bin.zip
          export PATH=$PATH:$(pwd)/gradle-8.2/bin
          
          # Generate wrapper
          gradle wrapper
          
          if [ -f "./gradlew" ]; then
            echo "Successfully generated gradlew"
            chmod +x ./gradlew
            echo "GRADLEW_PATH=./gradlew" >> $GITHUB_ENV
            echo "PROJECT_DIR=." >> $GITHUB_ENV
          else
            echo "Failed to generate gradlew"
            exit 1
          fi
        fi
        
    - name: Build Debug APK
      run: |
        echo "Using gradlew at: ${{ env.GRADLEW_PATH }}"
        echo "Project directory: ${{ env.PROJECT_DIR }}"
        
        # Change to the project directory
        cd "${{ env.PROJECT_DIR }}"
        
        # Run the build with explicit Java home
        "${{ env.GRADLEW_PATH }}" assembleDebug \
        --no-daemon \
        --stacktrace \
        -Dorg.gradle.java.home=$JAVA_HOME \
        -PversionCode=${{ env.VERSION_CODE }} \
        -PversionName=${{ env.VERSION_NAME }}
    
    - name: Find and package APK
      id: find-apk
      run: |
        echo "::group::Finding APK files"
        
        # Create artifacts directory
        mkdir -p artifacts
        
        # Find all generated APK files
        APK_FILES=$(find . -name "*.apk" -type f)
        
        if [ -z "$APK_FILES" ]; then
          echo "No APK files found in the main search!"
          
          # Try a more specific path if we know the project directory
          if [ -n "${{ env.PROJECT_DIR }}" ]; then
            echo "Searching for APKs in specific build output directories..."
            
            # Common output paths for Android APKs
            COMMON_PATHS=(
              "${{ env.PROJECT_DIR }}/app/build/outputs/apk"
              "${{ env.PROJECT_DIR }}/build/outputs/apk"
              "${{ env.PROJECT_DIR }}/*/build/outputs/apk"
            )
            
            for path in "${COMMON_PATHS[@]}"; do
              echo "Checking $path"
              if [ -d "$path" ]; then
                SPECIFIC_APK_FILES=$(find "$path" -name "*.apk" -type f)
                if [ -n "$SPECIFIC_APK_FILES" ]; then
                  APK_FILES="$SPECIFIC_APK_FILES"
                  echo "Found APKs in $path"
                  break
                fi
              fi
            done
          fi
          
          # If still no APKs found, exit with error
          if [ -z "$APK_FILES" ]; then
            echo "Listing all directories to debug:"
            find . -type d | grep -v "node_modules" | sort
            echo "No APK files found anywhere! Build might have failed."
            exit 1
          fi
        fi
        
        echo "Found APK files:"
        echo "$APK_FILES"
        
        # Use the most recently modified APK
        LATEST_APK=$(ls -t $APK_FILES | head -n 1)
        echo "Selected most recent APK: $LATEST_APK"
        
        # Copy APK to artifacts directory with a standardized name
        APK_FILENAME="MoneyPulse-debug-${{ env.VERSION_NAME }}.apk"
        cp "$LATEST_APK" "artifacts/$APK_FILENAME"
        echo "APK copied to: artifacts/$APK_FILENAME"
        
        # Set environment variable for APK path
        echo "APK_PATH=artifacts/$APK_FILENAME" >> $GITHUB_ENV
        echo "apk_path=artifacts/$APK_FILENAME" >> $GITHUB_OUTPUT
        echo "::endgroup::"
        
    # Simplified artifact storage - write to actions artifact storage directly
    - name: Upload Artifacts
      run: |
        echo "::group::Uploading artifacts"
        
        # Create a tarball of the artifacts directory
        tar -czvf artifacts.tar.gz artifacts/
        
        # Artifacts are automatically saved if they're in the .github/artifacts directory
        mkdir -p .github/artifacts
        mv artifacts.tar.gz .github/artifacts/
        
        echo "Artifacts have been packaged and saved to GitHub storage"
        echo "::endgroup::"
        
    # Create GitHub Release for tagged commits (using artifact directly)
    - name: Release
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        echo "::group::Creating release"
        
        # Get the tag name
        TAG_NAME=${GITHUB_REF#refs/tags/}
        echo "Creating release for tag: $TAG_NAME"
        
        # Use GitHub CLI to create a release and upload the APK
        # This requires the GITHUB_TOKEN to have the appropriate permissions
        gh release create "$TAG_NAME" \
          --title "MoneyPulse $TAG_NAME" \
          --notes "Release $TAG_NAME" \
          "${{ env.APK_PATH }}"
        
        echo "Release created successfully"
        echo "::endgroup::"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 